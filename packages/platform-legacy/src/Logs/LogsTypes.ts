import { PageContent, PageDirection, Pagination, StringAnyMap } from '../CommonTypes';

export interface LogConfig {
  /**Config for the root logger. The sink defined here (INTERNAL if absent) will be used by default by other loggers.*/
  rootLoggerConfig: RootLoggerConfig;
  /**List of defined sinks. It is useless to configure more than one INTERNAL or REAL_TIME sink*/
  sinkConfigs?: LogSinkConfig[];
  /**Maps loggers to levels (DEBUG, INFO, ...). A logger name should appear only once in this list*/
  loggers?: LoggerConfig[];
}
export interface LogEntries {
  /**Start timestamp (inclusive)*/
  start?: number;
  /**EMPTY DESC*/
  entries?: PageContent<LogEntry>;
  /**Start timestamp (inclusive)*/
  stop?: number;
  /**Pagination information*/
  page?: Pagination;
}
export interface LogEntry {
  /**Refines the identification of a connected client. Automatically set by the server from the current connection if available.*/
  resource?: string;
  /**Context ID. Clients and developers must not pass this explicitly. This value is generated by the server and can be passed back by the worker SDKs.*/
  contextId?: string;
  /**server-generated timestamp*/
  timestamp?: number;
  /**For developer-defined values, tags, etc... A typical usage is to trace an application-generated transaction ID across several API calls, to be able to retrace a full click-stream afterwards*/
  custom?: StringAnyMap;
  /**The actual data you are logging. Can be a text message, or more structured data.*/
  data?: any;
  /**Logger name. Hierarchical, dot-separated identifier, such as 'myClass.myVerb' to ease log storage and filtering.*/
  logger?: string;
  /**Optional User key. When calling the API, defaults to the current (calling) user's primary key. For impersonation purposes, the caller may use the key of another user, provided that the proper authorizations have been given by the impersonated user*/
  owner?: string;
  /**Levels ensure that requests end up in the logs only when configured to do so.*/
  level?: LogLevel;
  /**server node name*/
  node?: string;
  /**User supplied timestamp. The server will still store its own timestamp.*/
  timestampOverride?: number;
}
export enum LogLevel {
  /**All information usually needed by developers or administrators to help diagnose problems.*/
  DEBUG = 'DEBUG',
  /**Something is wrong enough to compromise the correct processing of a request (for example a mandatory external resource, e.g. another HTTP server, is not responding)*/
  ERROR = 'ERROR',
  /**Lowest level of traces. All service verbs at the TRACE level will dump all input and output. DO NOT enable TRACE unless you are prepared to go through a very high volume of logs. Enabling TRACE may degrade application performance.*/
  TRACE = 'TRACE',
  /**Anything that can cause application misbehaviour, but that does not need human intervention.*/
  WARN = 'WARN',
  /**Events meaningful for your application should go there : the creation of a user, a purchase, etc ...*/
  INFO = 'INFO'
}
export interface LogListRequest {
  /**Start timestamp (inclusive)*/
  start?: number;
  /**Start timestamp (inclusive)*/
  stop?: number;
  /**Pagination information*/
  page?: Pagination;
}
export interface LogRequest {
  /**Refines the identification of a connected client. Automatically set by the server from the current connection if available.*/
  resource?: string;
  /**Context ID. Clients and developers must not pass this explicitly. This value is generated by the server and can be passed back by the worker SDKs.*/
  contextId?: string;
  /**For developer-defined values, tags, etc... A typical usage is to trace an application-generated transaction ID across several API calls, to be able to retrace a full click-stream afterwards*/
  custom?: StringAnyMap;
  /**The actual data you are logging. Can be a text message, or more structured data.*/
  data?: any;
  /**Logger name. Hierarchical, dot-separated identifier, such as 'myClass.myVerb' to ease log storage and filtering.*/
  logger?: string;
  /**Optional User key. When calling the API, defaults to the current (calling) user's primary key. For impersonation purposes, the caller may use the key of another user, provided that the proper authorizations have been given by the impersonated user*/
  owner?: string;
  /**Levels ensure that requests end up in the logs only when configured to do so.*/
  level?: LogLevel;
  /**User supplied timestamp. The server will still store its own timestamp.*/
  timestampOverride?: number;
}
export interface LogSinkConfig {
  /**Sink name*/
  name: string;
  /**Sink type*/
  sinkType: LogSinkType;
  /**specific to each sink type*/
  sinkConfig?: StringAnyMap;
}
export enum LogSinkType {
  /**missing enum desc*/
  TODO = 'TODO',
  /**missing enum desc*/
  INTERNAL = 'INTERNAL',
  /**missing enum desc*/
  REAL_TIME = 'REAL_TIME'
}
export interface LoggerConfig {
  /**Sink name references, as defined in the sinkConfigs section of the LogConfig. When none is given, the root sink is used.*/
  sinkNames?: string[];
  /**Logger name. Hierarchical, dot-separated identifier, such as 'myClass.myVerb' to ease log storage and filtering.*/
  logger: string;
  /**Levels ensure that requests end up in the logs only when configured to do so.*/
  level: LogLevel;
}
export interface RootLoggerConfig {
  /**Sink name references, as defined in the sinkConfigs section of the LogConfig.*/
  sinkNames: string[];
  /**Levels ensure that requests end up in the logs only when configured to do so.*/
  level: LogLevel;
}
