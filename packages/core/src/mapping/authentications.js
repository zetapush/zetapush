import { Service } from './core';
/**
 * Delegating authentication
 *
 * This authentication delegates authentication to an external auth provider
 * <br>When a zetapush client handshakes with a delegated authentication, the 'token' field given by the client is sent to the configured remote server as part of the URL
 * <br>The response must be in JSON format
 *  Each key of the response will be considered a user information field name
 * <br>The handshake from the server will return the primary key in a field named 'login' (regardless of the actual key name you might have chosen)
 * */
/**
 * End-user API for the delegating authentication
 *
 * Provisionning verbs.
 * @access public
 * */
export class Delegating extends Service {
  /**
   * Get default deployment id associated to Delegating service
   * @return {string}
   */
  static get DEFAULT_DEPLOYMENT_ID() {
    return 'delegating_0';
  }
}
/**
 * Local authentication
 *
 * Zetapush local authentication
 *  The configurer can choose the primary key and mandatory user fields for account creation
 *  The field 'zetapushKey' is generated by the server and MUST not be used : it contains the unique key of the user inside a sandbox (it can be obtained from inside a macro with the <b>__userKey</b> pseudo-constant)
 * */
/**
 * End-user API for the simple local authentication
 *
 * These API verbs allow end-users to manage their account.
 * @access public
 * */
export class Simple extends Service {
  /**
   * Get default deployment id associated to Simple service
   * @return {string}
   */
  static get DEFAULT_DEPLOYMENT_ID() {
    return 'simple_0';
  }
}
/**
 * Weak authentication
 *
 * The weak authentication allows for anonymous authentication of devices
 *  Such devices can display a qrcode to allow regular users to take control of them
 * */
/**
 * User API for weak devices control
 *
 * User API for control and release of weakly authenticated user sessions.
 * @access public
 * */
export class Weak extends Service {
  /**
   * Get default deployment id associated to Weak service
   * @return {string}
   */
  static get DEFAULT_DEPLOYMENT_ID() {
    return 'weak_0';
  }
  /**
   * Controls a session
   *
   * Takes control of a weak user session, identified by the given public token.
   * The public token has been previously made available by the controlled device, for example by displaying a QRCode.
   * Upon control notification, the client SDK of the controlled session is expected to re-handshake.
   * */
  control({ publicToken, fullRights }) {
    return this.$publish('control', { publicToken, fullRights });
  }
  /**
   * Returns the current token
   *
   * Returns your current session's private token. The token field may be null, if you did not log in with this authentication.
   * The token can be used to log in as the same weak user another time.
   * */
  getToken() {
    return this.$publish('getToken', {});
  }
  /**
   * Releases a session
   *
   * Releases control of a weak user session, identified by the given public token.
   * The weak user session must have been previously controlled by a call to 'control'.
   * */
  release({ publicToken, fullRights }) {
    return this.$publish('release', { publicToken, fullRights });
  }
}
